---
layout: post
title:  Spring Surf explained
subtitle: 
date:   2013-01-25 10:00:00
categories: spring-surf
excerpt: Spring Surf is a "View Composition framework" that can be used as a View in Spring MVC
---


## Overview

Spring Surf is a "View Composition framework" that can be used as a View in Spring MVC.

In Spring Surf each page is assembled with reusable template and multiple reusable components, called Web-Scripts. 
Template specifies page's HTML that can include components (Web-Scripts) to render parts of the page.

Web-Script is represented by three files:

* description xml
* free-marker template
* controller script (JavaScript or java)

Alfresco calls Web-Script "mini MVC" where free-marker templates are View, controller script is controller, 
and Model is the context accessible from controller and free-marker template.

## Spring Surf is not MVC framework

Alfresco Quick Start is trying to position Spring Surf as MVC framework on itself, 
but its a far stretch cause when Spring Surf page is being rendered the View is already being written to response, 
so its *too late* to make any "Control" decisions like rendering another view or showing Error page or forwarding to another Page.

Here are the reasons one should not use Spring Surf as MVC framework on itself:

* Inability to separate Controller from View (its impossible to make a decision in the controller, which view to display, or even forward to another controller or page)
* Inability to handle exceptions gracefully (when exception occurs during JavaScript execution or free-marker template processing, the request is already being written, so its impossible to handle failure with dedicated error page. The error message will be displayed within current, potentially, broken page)
* Inability to reuse controllers across multiple views (this actually relates to bullet one)
* Inability to apply security rules to multiple pages

## Spring Surf is a "View Composition framework"

While Spring Surf is not an MVC framework, it is very sophisticated and powerful "View Composition framework" that 
integrates nicely with Spring MVC. Here we will try to explain how it works.

These are tree main types of artifacts, needed to create views:

__Pages__

* defined in `WEB-INF/pages`
* consists of:
  * __description .xml__ - specifies Page Id, Template to use and declares page specific Components


__Templates__

* defined in `WEB-INF/templates`
* consists of:
  * __description .xml__ - specifies Template Id and declares template specific Components
  * __free-marker .ftl__ - specifies HTML structure of the page and uses Components to render regions of HTML
  * __controller .js__ (optional)


__Web-Scripts__

* defined in `WEB-INF/webscripts`
* consists of:
  * **description .xml** - specifies webscript URL - (used in component declarations)
  * **free-marker .ftl** - html template
  * **controller .js** (optional)

#### Web-Scripts

Web-scripts are used to render snippets of html that can be reused across pages. 
Web-scripts implement presentation logic in JavaScript controller, which computes 
values and puts them in model (similar to controller in Spring MVC). 
That model is available in free-marker template.

Web-scripts are used by Templates (see below). In order to use Web-script, it should be declared as component. 
The Template then specifies which region of html will be rendered by which component.

In typical dynamic web-application most of the content is generated by web-scripts:

* dynamic content
* reusable static html
* content from alfresco repo

##### Naming Web-Script artifacts:

Web-script artifacts should follow this naming convention:

* For GET requests:
  * *name.get.desc.xml* - descriptor
  * *name.get.html.ftl* - template
  * *name.get.js* - js controller
* For POST requests:
  * *name.post.desc.xml* - descriptor
  * *name.post.html.ftl* - template
  * *name.post.js* - js controller


*Note:* 
> If POST web-script is not provided, the GET web-script will be used by default. 
> This is very useful for rendering HTML forms. We only need to provide GET web-script for "getting" 
> the form and for displaying form with error when POST has failed.

#### Templates

In Spring-Surf we use Template to define common structure of pages. At minimum, template needs **description xml** 
and **free-marker ftl file**. Optionally, templates can have **controller script** if template has some logic to execute.

A site can have one or many templates. A template would define common HTML for all the pages using this template. 
For example, we could have one template for Logged-out state of the application, and one template for Logged-in state, with the user account Menu:

![Logged out template](/assets/images/mockup_Logged out template.png)

```html
<html>
    <body>
        <@region id="Header" scope="global"/>
        <div class="content">
            <@region id="Content" scope="page"/>
        </div>  
        <@region id="Footer" scope="global"/> 
    </body>
</html>
```


![Logged in template](/assets/images/mockup_Logged in template.png)

```html
<html>
    <body>
        <@region id="Header" scope="global"/>

        <div class="content">
            <@region id="Menu" scope="template"/>
            <@region id="Content" scope="page"/>
        </div>  

        <@region id="Footer" scope="global"/> 
    </body>
</html>
```


The `@region` tags above are the way templates specify which component to use to render particular "Region" of the page. 
The `id` and `scope` are used to locate particular component.

For example
`<@region id="Content" scope="page"/>`
means we want to use "Content" component, declared with "page" scope.

Lets talk about components...

#### Components

Component is basically a web-script bound to an *ID* and *Scope*.

In order to use web-script, first it should be declared as component. Below we declare component by binding `/contactus` 
web-script to `Content` component id.

```xml
<components>      
    <component>
        <region-id>Content</region-id>            
        <url>/contactus</url>
    </component>
</components>
```

__Note:__
> `<region-id>` is very confusing name. This is really a component-id.

##### Component scope

Component scope is implicit and derived from the location of the component declaration.

Components can be declared with three scopes:

* **page** - means that component is page specific (declared in current page)
* **template** - means that component is template specific (declared in current template)
* **global** - global component are declared separately on file system and always available.

"**Page**" scope allows Templates (which are generic) to render page-specific content. 
"Logged in template", for example, can be used by many pages. 
`<@region id="Content" scope="page"/>` means that in order to render page-specific content, 
all pages should declare component "Content". 
If component "Content" is declared in Template (i.e. with "template" scope), it will be ignored.
"**Template**" scope is used to limit component only to current template. Other templates can not use Component declared in this Template.
"**Global**" scope makes Component available globally to all templates

##### Page component

Page decalration consist of only one artifact - page description xml

Here is the example of page description xml:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<page> 
    <id>contactus</id>
    <description>Contact Us Page</description>   
    <template-instance>logged-in-template</template-instance>
    <authentication>none</authentication>
    <components>    
        <component>
            <region-id>Content</region-id>            
            <url>/contactus</url>
        </component>
    </components>
</page>
```

Page definition specifies:

* **id** - to be used by Spring framework to render this particular page.
* **template-instance** - template to use to render this page
* **components** - page specific components (components with page scope)

##### Template component

Here we define "logged-in-template", with template specific component - "Menu"

```xml
<?xml version="1.0" encoding="UTF-8"?>
<template-instance>
    <title>logged-in-template</title>  
    <description>Template used by all logged-in pages</description>
    <template-type>logged-in-template</template-type>     
    <components>
        <component>
            <region-id>Menu</region-id>            
            <url>/user-account-menu</url>
        </component>    
    </components>   
</template-instance>
```


##### Global component

Global components are defined in their own xml file, in `surf/site/components` directory (should be included in web-application classpath).

Here we declare global "footer" component (see `<guid>`), that binds "/footer" web-script (see `<url>`) to "footer" id (see `<region-id>`)

```xml
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<component> 
  <guid>global.footer</guid>  
  <component-type-id>webscript</component-type-id>  
  <title>global.footer</title>  
  <description>global.footer</description>  
  <url>/footer</url>  
  <resources/>  
  <scope>global</scope>  
  <source-id>global</source-id>  
  <region-id>footer</region-id>  
  <properties/>
</component>
```

